local gc = game.translate_string
local rand = math.random
local send_tip = news_manager.send_tip
local get_config = arti_lootboxes_mcm.get_config

-- importer for lootbox -> loot pool
local ini_pools = ini_file("items\\lootboxes\\loot_pools\\importer.ltx")
-- importer for loot pool -> contents
local ini_contents = ini_file("items\\lootboxes\\loot_contents\\importer.ltx")
local ini_uniques = ini_file("items\\lootboxes\\unique_contents\\importer.ltx")
local ini_lootbox = ini_file("items\\items\\items_rootbox.ltx")

-- custom loaded contents
contents_custom = {}
pools_custom = {}
-- cached maps, these will get hydrated as more loot is rolled
local pool_cache = {}
local contents_cache = {}
-- map box groups to boxes
local variant_map = {}
-- track boxes that contain uniques, as well as what uniques have been seen so far
local uniques_cache = {}
-- store all lootbox contents
local lootbox_contents = {}
-- stolen from treasure_manager
local item_prop_table = { cond_r = {30,70} , cond_ct = "part" , cond_cr = {0.5,0.75,1} }

map_tiers = {}

local function save_state(mdata) 
	mdata.lootbox_contents = lootbox_contents
end

local function load_state(mdata) 
	lootbox_contents = mdata.lootbox_contents or {}
end

-- unregister boxes that are deleted
local function server_entity_on_unregister(se_obj)
	if lootbox_contents[se_obj.id] then
		lootbox_contents[se_obj.id] = nil
	end
    if not lootbox_contents.uniques then
        lootbox_contents.uniques = {}
    end
    -- if a unique box is deleted, add it back to the pool
    if lootbox_contents.uniques[se_obj.id] then
        local unique = lootbox_contents.uniques[se_obj.id]
        uniques_cache[se_obj:section_name()][unique] = true
		lootbox_contents.uniques[se_obj.id] = nil
        
	end
end

function print_dbg(text, ...) 
	if get_config("debug") then
		printf("lootboxes | %s | " .. text, time_global(), ...)
	end
end

function get_loot_string(id)
    return lootbox_contents[id]
end

-- rand(100) against these odds
function roll(odds)
    return rand(100) <= odds
end

-- returns 1 with 60% chance, 2 with 30%, 3 with 10%
function weighted_roll()
    local roll = rand(10)
    if roll == 10 then return 3
    elseif roll > 6 then return 2
    else return 1 end
end

-- return random entry from integer-indexed table
function random_entry(t)
    t = t or {}
    return t[rand(#t)]
end

-- convert a comma-separated string of sections and numbers into a table
function parse_lootstring(str)
    local temp = str_explode(str, ",")
    local t = {}
    for i=1,#temp-1, 2 do
        table_upsert(t, temp[i], temp[i+1])
        -- t[temp[i]] = temp[i+1]
    end
    return t
end

-- str_explode but they get parsed into numbers
function str_explode_num(str, sep, plain)
	if not (str and sep) then
		printe("!ERROR str_explode | missing parameter str = %s, sep = %s",str,sep)
		callstack()
	end
	if not (sep ~= "" and str:find(sep,1,plain)) then
		return { tonumber(str) }
	end
	local t = {}
	local size = 0
	for s in str:gsplit(sep,plain) do 
		size = size + 1
		t[size] = tonumber(trim(s))
	end
	return t
end

function table_upsert(t, k, v)
    if type(v) == "number" then
        t[k] = t[k] and t[k] + v or v
    else
        t[k] = v
    end
end

local not_wpn = {
    ["WP_BINOC"] = true,
    ["WP_SCOPE"] = true,
    ["WP_SILEN"] = true,
    ["WP_GLAUN"] = true
}

function sec_is_weapon(section)
    local class = SYS_GetParam(0, section, "class")
    if string.find(section, "wpn_") then
        return not_wpn[class] == nil
    else return false
    end
end

function init()
    local ini_map = ini_file("items\\settings\\lootbox_map_distribution.ltx")
    ini_map:section_for_each(function(map)
        if not map_tiers[map] then map_tiers[map] = {} end
        print_dbg("processing map %s", map)
        local line_count = ini_map:line_count(map) or 0
        local ref = map_tiers[map]
        for i=0,line_count-1 do
            local junk1, tier, values = ini_map:r_line_ex(map, i, "", "")
            print_dbg("adding boxes %s to map %s, tier %s", values, map,tier)
            ref[tonumber(tier)] = values and str_explode(values, ",") or {}
        end
    end)

    local ini_stalker = ini_file("items\\settings\\lootbox_stalker_distribution.ltx")
    ini_stalker:section_for_each(function(faction)
        if not map_tiers[faction] then map_tiers[faction] = {} end

        print_dbg("processing community %s", faction)
        local line_count = ini_stalker:line_count(faction) or 0
        local ref = map_tiers[faction]
        for i=0,line_count-1 do
            local junk1, tier, values = ini_stalker:r_line_ex(faction, i, "", "")
            local loot_table = values and str_explode(values, ",") or {["nothing"] = 1}
            print_dbg("adding loot %s to stalker faction %s", values, map,tier)
            ref[tonumber(tier)] = loot_table
        end
    end)

    ini_lootbox:section_for_each(function(section)
        local group = ini_lootbox:r_string_ex(section, "box_group")
        if group then
            if not variant_map[group] then variant_map[group] = {} end
            table.insert(variant_map[group], section)
        end
    end)
    init_uniques()
end

function init_uniques()
    -- hydrate the box uniques that have not been seen so far
    -- mechanism: initially add all sections to this cache
    -- when a unique box rolls, add an entry in uniques child table associating box id to what unique section exactly
    -- when that box is opened (or deleted), drop the entry
    -- opening also marks that entry as being unable to drop again
    ini_uniques:section_for_each(function(section)
        if not lootbox_contents.uniques then lootbox_contents.uniques = {} end
        if lootbox_contents.uniques[section] then return end
        local box = ini_uniques:r_string_ex(section, "box")
        if not uniques_cache[box] then uniques_cache[box] = {} end
        uniques_cache[box][section] = true
    end)
end

-- given a group id, return a lootbox section from that group, if applicable
function pick_lootbox(group)

    if variant_map[group] then
        print_dbg("Checking group %s", group)
        return random_entry(variant_map[group])
    else
        return "lootbox_"..group
    end

end

-- Weapon data is stored as weapon_section,flags_ammotype_cond
function append_weapon(template, section, min, add_ammo)
    template = template or {}
    if not sec_is_weapon(section) then
        print_dbg("Section %s is not weapon! Returning only 1" , section)
        table_upsert(template, section, 1)
        return
    end
    if string.find(section, "knife") or string.find(section, "axe") then
        print_dbg("Appending melee weapon")
        table_upsert(template, section, "0_0_"..rand(min,99))
        return
    end
    local loot_str = ""
    local flag = 0

    if (ini_sys:r_float_ex(section,"scope_status")) then
        flag = flag + 1
    end

    if (ini_sys:r_float_ex(section,"grenade_launcher_status")) then
        flag = flag + 2
    end

    if (ini_sys:r_float_ex(section,"silencer_status")) then
        flag = flag + 4
    end

    flag = rand(0,flag)

    ammos = parse_list(ini_sys,section,"ammo_class")
    ct = ammos and #ammos
    ammo_type = ammos and ct and rand(0,ct-1) or 0
    ammo_section = ammo_type and ammos[ammo_type+1]

    local condition = rand(min, 99)
    print_dbg("Appending weapon of type %s", section)
    table_upsert(template, section, flag.. "_"..ammo_type.."_"..condition)
    if add_ammo and ammos and ct and ct > 0 then 
        table_upsert(template, ammos[1], rand(3))
    end
    return template
end


-- on the chance that all maxes don't sum up, cut after this many iterations
local MAX_ITER = 10000
-- build a loot template to be substituted with items
-- loot template is table mapping item pools = quant of items
function build_template(template, section, max, chance_mult)
    template = template or {}
    if ini_pools:section_exist("lootbox_"..section) then
        -- cache the table
        if not pool_cache[section] then
            n = ini_pools:line_count("lootbox_"..section)
            local pool = {}
            for i=0,n-1 do
                local content = {}
                _, id, value = ini_pools:r_line_ex("lootbox_"..section,i,"","")
                print_dbg("Adding %s of %s", value, id)
                values = str_explode_num(value, ",")
                content.section = id
                content.size = values[1]
                content.limit = values[2]
                content.chance = values[3]
                table.insert(pool, content)
            end
            if pools_custom[section] and not is_empty(pools_custom[section]) then
                print_dbg("Adding %s custom entries for %s", #pools_custom[section], section)
                for k,v in pairs(pools_custom[section]) do
                    local content = {}
                    values = str_explode_num(v, ",")
                    content.section = k
                    content.size = values[1]
                    content.limit = values[2]
                    content.chance = values[3]
                    table.insert(pool, content)
                end
            end
            pool_cache[section] = pool
        end
        -- build
        max = max or 10
        bias = bias or 1
        print_dbg("Adding %s items, bias %s", max, bias)
        pool = pool_cache[section]
        iters = 0
        while max > 0 do
            -- pick a random entry from the pool
            if iters > MAX_ITER then break end
            item = pool[rand(#pool)]
            print_dbg("Rolled item %s, chance is %s", item.section, item.chance)
            local curr_amt = template[item.section] or 0
            if curr_amt < item.limit and roll(item.chance * bias) then
                table_upsert(template, item.section, 1)
                max = clamp(max - item.size, 0, max)
            end
            iters = iters + 1
        end
    end
end

-- sub item pools for actual items in content template
function process_template(template, box_section)
    local processed = {}
    for sec,v in pairs(template) do
        for j=1,v do
            local id, value = random_item_entry(sec)
            print_dbg("Adding %s amount of %s to lootbox",value, id)
            if sec_is_weapon(id) then
                local condition = SYS_GetParam(2, box_section, "weapon_condition") or rand(20, 80)
                append_weapon(processed, id, condition)
            -- elseif id == "money" then
            --     local money_amt = rand(value) or 1000
            --     table_upsert(processed, k, money_amt)
            elseif item_device.device_npc_pda[id] then
                if not processed[id] then
                    local schmuck_id = pda_custom.cache_local_schmuck()
                    print_dbg("Adding %s's pda to the loot", schmuck_id)
                    if schmuck_id ~= 0 then
                        table_upsert(processed, id, schmuck_id)
                    end
                end
            else
                local max_multiuse = SYS_GetParam(1, box_section, "multiuse_full") or false
                local max_uses = SYS_GetParam(2, id, "max_uses") or 1
                if not max_multiuse and max_uses > 1 then
                    id = id .. "__" .. rand(max_uses)
                end
                table_upsert(processed, id, value)
            end
        end
    end
    return processed
end

function create_lootstring(template)
    str = ""
    for k,v in pairs(template) do
        str = str .. k .. "," .. v .. ","
    end
    return str
end

-- select a random item from the content pool
function random_item_entry(section)
    print_dbg("Adding item from content section %s", section)
    if ini_contents:section_exist("lootbox_"..section) then
        if not contents_cache[section] then
            n = ini_contents:line_count("lootbox_"..section)
            local contents = {}
            for i=0,n-1 do
                _, id, value = ini_contents:r_line_ex("lootbox_"..section,i,"","")
                if not value or value == "" then value = 1 end
                print_dbg("Adding %s of %s", value, id)
                for j=0,value do
                    table.insert(contents, id)
                end
                if contents_custom[section] and not is_empty(contents_custom[section]) then
                    print_dbg("Adding %s custom entries for %s", #contents_custom[section], section)
                    for k,v in pairs(contents_custom[section]) do
                        table.insert(contents, v)
                    end
                end
            end
            contents_cache[section] = contents
            -- end
        end
        
        local contents = contents_cache[section]
        local selection = random_entry(contents)
        if string.find(selection, ",") then
            local split = str_explode(selection, ",")
            return split[1], tonumber(split[2])
        else
            return selection, 1
        end
    else
        printf("!!Content section %s not found!!", section) 
        return "duct_tape",1
    end
end

-- attempt to populate a unique. if it fails, we can provide normal contents
function try_populate_unique(box_id, box_section)
    u = uniques_cache[box_section]
    local next = next
    if not u or next(u) == nil then return "" end
    if rand(10) ~= 10 then return "" end
    local unique_sec = random_key_table(u)
    local unique_contents = ini_uniques:r_string_ex(unique_sec, "contents")
    print_dbg("Putting custom contents %s into box %s", unique_contents, box_section)

    lootbox_contents.uniques[box_id] = unique_sec
    lootbox_contents[box_id] = unique_contents
    if (box_section == "lootbox_4") then
        lootbox_contents.spooky = box_id
    end
    
    uniques_cache[box_section][unique_sec] = nil
    return unique_contents
end

function populate_lootbox(box_id, box_section)
    if not lootbox_contents[box_id] then
        print_dbg("Populating lootbox loot for %s of type: %s",box_id,  box_section)
        local loot_type = SYS_GetParam(0,box_section,"loot_type")
        print_dbg("Loot type is %s", loot_type)
        -- populate lore box, 10% chance
        local loot_str = try_populate_unique(box_id, box_section)
        if loot_str ~= "" then
            -- no action required
        elseif loot_type == "weapon" then
            -- spawn the weapon, roll for condition + attachments + spare ammos
            local weapon_tbl = {}
            local loot_section = SYS_GetParam(0, box_section, "contents")
            local section, value = random_item_entry(loot_section, true)
            local condition = SYS_GetParam(2, box_section, "weapon_condition") or rand(20, 80)
            append_weapon(weapon_tbl, section, condition, rand(2) == 1)
            loot_str = loot_str .. create_lootstring(weapon_tbl)
        elseif loot_type == "grab" then
            local box_template = {}
            -- grab a template, iterate through the pairs of items and populate bsaed on loot
            local loot_sec = SYS_GetParam(0, box_section, "contents")
            local min, max = unpack(str_explode_num(SYS_GetParam(0, box_section, "items_range"), ","))
            local to_roll = rand(min, max)
            -- bias skews the drop rate for rare stuff up if less items spawn
            local bias = 1 + ( 2 * clamp(max - to_roll, 1, 999) / clamp(max - min, 1, 999) )
            build_template(box_template, loot_sec, to_roll, bias)
            local loot_template = process_template(box_template, box_section)
            loot_str = loot_str .. create_lootstring(loot_template)
        end

        lootbox_contents[box_id] = loot_str
        print_dbg("Lootbox final contents for %s: %s", box_id, loot_str)
    end
end

function actor_on_item_take_from_box(box,itm)
    local id = box:id()
    if lootbox_contents[id] == true then
        lootbox_contents[id] = nil
    end
end

function spook_player(obj)
    if lootbox_contents.spooky == obj:id() then
        send_tip(db.actor, gc("st_spooky_"..rand(4)), nil, "swiss_knife", 6000)
    end
end


function on_item_drag_dropped(from, to, slot_from, slot_to)
	
	local item_from = from:section()
	local item_to = to:section()
    -- only two are valid - item_from is lockpick and item_to is lockpick set, or item_from is set and item_to is lockbox
    local challenge_rating = SYS_GetParam(2,item_to,"difficulty")
    local open_type = SYS_GetParam(2,item_from,"open_type")
    local open_power = SYS_GetParam(2,item_from,"open_power")
    local expire = SYS_GetParam(0,item_from,"expire_type")
    print_dbg("Drag %s (Open type is %s, open power is %s) on %s (CR %s).", item_from, open_type, open_power, item_to, challenge_rating)
    if open_type and challenge_rating ~= nil then
        if not open_power then
            open_power = pickset_binder.get_power(from:id())
        end
        if challenge_rating > open_power then
            send_tip(db.actor, gc("st_cant_unlock"), nil, "swiss_knife", 6000)
        else
            open_lootbox(to, open_type)
            if expire == "degrade" then
                pickset_binder.modify(from:id(), challenge_rating * -1)
            elseif expire == "destroy" then
                alife_release(from)
            end
        end
    elseif string.find(item_from, "wpn_axe") and SYS_GetParam(1, item_to, "can_smash") then
        -- smesh
        if (from:condition() > 0.25) then
            from:set_condition(clamp(from:condition() - 0.25, 0, 1))
        else
            alife_release_id(from:id())
        end
        open_lootbox(to, 2)
    end
end


-- Weapon data is stored as weapon_section,flags_ammotype_cond
function give_weapon(weapon, attachment_data)
    local table = str_explode(attachment_data, "_")
    local se_obj = alife_create(weapon,db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id(),db.actor:id(),false)
    local data = utils_stpk.get_weapon_data(se_obj)
    local cond = tonumber(table[3]) or 75
    if (data) then
        data.condition = (cond/100)
        data.addon_flags = tonumber(table[1])
        data.ammo_type = tonumber(table[2])
        utils_stpk.set_weapon_data(data, se_obj)
    end
    alife():register(se_obj)
    print_dbg("Granting weapon of type %s", weapon)
    local name = SYS_GetParam(0, weapon, "inv_name")
    local quality = math.floor((cond - 50) / 25) + 1
    local message =  gc("st_weapon_"..quality).." ".. gc(name) .. "\\n"
    -- send_tip(db.actor, message, nil, "swiss_knife", 6000)
    return message

end

-- method: 0 = lockpick, 1 = key, 2 = smash w. axe
function open_lootbox(box, method)
    
	local id = box:id()

	--printf("try_spawn_treasure [%s]",caches[id])

	if not (lootbox_contents[id]) then
        print_dbg("Lootbox contents not found. Populating.")
		populate_lootbox(id, box:section())
	end

    -- play cool animation, with cool sound
    if get_config("animation") == true then
        xr_effects.disable_ui_only(db.actor, nil)
        print_dbg("COOL ANIMATION AND SOUNDS")
        local sound_to_find = "$no_sound"
        if method == 0 then
            sound_to_find = "snd_open"
        elseif method == 1 then
            sound_to_find = "snd_open_key"
        elseif method == 2 then
            sound_to_find = "snd_open_axe"
        end
        local sound = SYS_GetParam(0,box:section(), sound_to_find)
        local delay = method == 2 and 2 or 5
        utils_obj.play_sound(sound)
        print_dbg("Start open box with id "..id)
        RemoveTimeEvent("lootbox","box_open " .. id)
        CreateTimeEvent("lootbox","box_open " .. id, delay, open_lootbox_timer, id)
    else
        RemoveTimeEvent("lootbox","box_open " .. id)
        CreateTimeEvent("lootbox","box_open " .. id, 0, open_lootbox_timer, id)
    end

end

function open_lootbox_timer(id)
    xr_effects.enable_ui_lite(db.actor, nil)

    if not lootbox_contents[id] then return false end
    print_dbg("Opening box with id "..id)
	local spawned_items = parse_lootstring(lootbox_contents[id])
    local str = gc("st_lootbox_get") .. ":\\n"
    -- give loot
    for section, quantity in pairs(spawned_items) do
        print_dbg("Creating %s of %s", quantity, section)
        if section == "spooky" then
            alife_create("m_poltergeist_normal_flame", db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id())
            send_tip(db.actor, gc("st_spooky_free"), nil, "swiss_knife", 6000)
            lootbox_contents.spooky = nil
        elseif section == "money" then
            local money_amt = tonumber(quantity) or 5000
            db.actor:give_money(money_amt)
           str = str ..money_amt .. " ".. gc("st_money") .. "\\n"
        elseif sec_is_weapon(section) then
            str = str .. give_weapon(section, quantity)
        elseif item_device.device_npc_pda[section] then
            local se_itm = alife_create_item(section, db.actor, item_prop_table)
            local id = se_itm and se_itm.id
            -- quantity will be the id of the schmuck this pda belongs to
            pda_custom.register_pda(tonumber(quantity), section, id)
        else
            local amt = tonumber(quantity) or 1
            for j=1,amt do
                local se_itm = alife_create_item(section, db.actor, item_prop_table)
            end
            if string.find(section, "__") then section = str_explode(section, "__")[1] end
            local item_name = ui_item.get_sec_name(section) or "of something"
            if string.find(section, "ammo") then
                if amt > 1 then
                    str = str..  amt.. " ".. gc("st_loot_ammos") .. " "..gc(item_name).. "\\n"
                else
                    str = str..  amt.. " ".. gc("st_loot_ammo") .. " "..gc(item_name).. "\\n"
                end
            else
                str = str..  amt.. " "..gc(item_name).. "\\n"
            end
        end
    end
    send_tip(db.actor, str, nil, "swiss_knife", 6000)
	lootbox_contents[id] = nil
    -- manage uniques - once player opens, remove unique from appearing again
    if lootbox_contents.uniques[id] then
        local unique_sec = lootbox_contents.uniques[id]
        lootbox_contents.uniques[id] = nil
        lootbox_contents.uniques[unique_sec] = true
        print_dbg("Lootbox unique %s opened", unique_sec)
    end
	lootbox_contents[id] = nil
    alife_release_id(id)
    return true
end

-- spawn kit and picks in technician inv

function IsMechanic(npc)
    return string.find(npc:section(), "mechanic") or string.find(npc:section(), "tech")
end

function create_tools()

    local npc = mob_trade.GetTalkingNpc()
    print_dbg("trade init with "..npc:character_name())
    if IsMechanic(npc) then
        local num_set = 0
        local num_picks = 0
        local num_bundle = 0

        local function search(temp, item)
            local item_section = item:section()
            if item_section == "lockpick" then
                num_picks = num_picks + 1
                print_dbg("found lockpick")
            elseif item_section == "bundle_lockpick" then
                num_bundle = num_bundle + 1
                print_dbg("found lockpick")
            elseif item_section == "lockpick_set" then
                num_set = num_set + 1
            end
        end
        npc:iterate_inventory(search, nil)
        num_picks = 5 - num_picks
        if num_picks > 0 then
            print_dbg("Spawning ".. num_picks .. " lockpicks")
            for i=1, num_picks do
                alife_create_item("lockpick", npc)
            end 
        end
        num_bundle = 5 - num_bundle
        if num_bundle > 0 then
            print_dbg("Spawning ".. num_bundle .. " bundles")
            for i=1, num_bundle do
                alife_create_item("bundle_lockpick", npc)
            end 
        end
        if num_set == 0 then
            print_dbg("spawning pickset")
            alife_create_item("lockpick_set", npc)
        end
    end
end


-- spawn lootbox in box, tie the contents of box to creation time to prevent RNG cheese
function spawn_lootbox(box)
    local id = box:id()
    if lootbox_contents[id] then return end
    local roll = rand(100)
    if roll <= get_config("stashchance") then
        local se_obj = alife_object(id) 
        local lvl = alife():level_name(game_graph():vertex(se_obj.m_game_vertex_id):level_id())
        print_dbg("spawning box in %s", lvl)
        if map_tiers[lvl] == nil then return end
        local tier = weighted_roll()
        c = #map_tiers[lvl][tier]
        print_dbg("Rolling tier %s, picking from %s choices", tier, c)

        local box_type = pick_lootbox(map_tiers[lvl][tier][math.fmod(roll, c) + 1])

        -- roll number from 1-4, corresponding to level of lootbox
        if ini_sys:section_exist(box_type) then
            print_dbg("Spawned in lootbox of type "..box_type)
            se_itm = alife_create_item(box_type, box)
            -- populate_lootbox(se_itm.id, "lootbox_"..box_type)
        else
            print_dbg("Could not spawn lootbox of type "..box_type)
        end
    end
    if roll <= 10 then
        local section = "lockpick"
        local roll = rand(20)
        -- 70% one pick, 25% bundle, 5% skelekey 
        if roll == 20 then
            section = "skeleton_key"
        elseif roll > 16 then
            section = "bundle_lockpick"
        elseif roll > 10 then
            section = "lockpick"
        end
        local se_obj = alife_create(section,box:position(),box:level_vertex_id(),box:game_vertex_id(),box:id(),false)
        alife():register(se_obj)
    end
    -- set box id to true to mark that is has been checked
    lootbox_contents[id] = true
end

-- spawn items on dead people
function spawn_stalker_loot(npc)

    if rand(100) <= get_config("deathchance") then
        local community = npc:character_community()
        if map_tiers[community] == nil then community = "stalker" end
        local table = map_tiers[community][weighted_roll()]
        if table[1] == "nothing" then return end

        local amt = rand(tonumber(table[2]))
        print_dbg("Spawning %s of %s on dead NPC", amt, table[1])
        for i=1,amt do
            se_obj = alife_create(table[1],  npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id(), false)
            alife():register(se_obj)
            print_dbg("registered object "..se_obj.id)
        end
    end
end

-- monkey patch loot managers
SpawnTreasure = treasure_manager.try_spawn_treasure

function treasure_manager.try_spawn_treasure(box)
    local id = box:id()

	--printf("try_spawn_treasure [%s]",caches[id])
    -- no spawn if the cache is already looted
	if not (treasure_manager.caches[id]) then
		return
	end
    spawn_lootbox(box)
    SpawnTreasure(box)
end

BuildFooter = ui_item.build_desc_footer
function ui_item.build_desc_footer(obj, sec, str)
    str = str or gc(ini_sys:r_string_ex(sec,"description"))
	if (not str) then return "" end

    local _str = ""
    
    local difficulty = SYS_GetParam(2, sec, "difficulty")
    if difficulty ~= nil then
        difficulty = 5 * difficulty
        local clr = utils_xml.get_color_con(100 - tonumber(difficulty))
        _str = clr .. " " .. gc("st_dot").. " " .. utils_xml.get_color("ui_gray_1") .. gc("st_box_difficulty") .. " " .. clr .. tostring(difficulty) .. "%" .. "\\n \\n" .. utils_xml.get_color("ui_gray_1")   
        return str .. _str
    else
        return BuildFooter(obj, sec, str)
    end
end
    

CreateReleaseItem = death_manager.create_release_item
function death_manager.create_release_item(npc)
    print_dbg("Interdicted death manager - spawning picks")
    CreateReleaseItem(npc)
    spawn_stalker_loot(npc)
end


function on_game_start()
	if (USE_MARSHAL) then 
		RegisterScriptCallback("save_state",save_state)
		RegisterScriptCallback("load_state",load_state)
	end
	RegisterScriptCallback("actor_on_item_take_from_box",actor_on_item_take_from_box)
    RegisterScriptCallback("ActorMenu_on_item_drag_drop",on_item_drag_dropped)
	RegisterScriptCallback("server_entity_on_unregister", server_entity_on_unregister)
    RegisterScriptCallback("ActorMenu_on_trade_started",create_tools)
	RegisterScriptCallback("actor_on_item_take",spook_player)
    init()
end
